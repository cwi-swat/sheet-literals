<!DOCTYPE HTML>
<head>
    <meta charset="utf-8" />
  <link rel="stylesheet" href="tufte.css"/>
  <link rel="stylesheet" href="latex.css"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">
    
<script src="https://cdn.rawgit.com/jquery/esprima/2.7.2/esprima.js"></script>
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="libsheet.js"></script>

  <script>
    $(document).ready(function() {
//    app.run();
    });
  </script>

    <style type="text/css" media="screen">
    #editor {
        margin: 0;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
    }
    </style>

</head>


<body>
  <article>
    <h1>Live Literals</h1>
    <p class="subtitle">Tijs van der Storm, Felienne Hermans</p>

    <blockquote>
      Live programming environments improve programmer experience by
      providing views of program execution which are continuously, and
      instantaneously updated.  In most existing work on liveness,
      these views are considered part of the IDE: separate windows,
      panels, or widgets allow programmers to inspect and interact
      with live data and program execution.  In this paper we present
      &#8220;live literals&#8221; where the source code itself is used
      as vehicle for immediate feedback and direct manipulation.  Live
      literals are like ordinary programming language literals, but
      they are automatically updated after certain changes to the
      code. We illustrate the concept of live literals in Javascript
      using three applications: embedded spreadsheets, live units
      tests, and probes.
    </blockquote>

    <section id="intro">
      <h2>Introduction</h2>

      <p>
        Live programming is about improving programmer experience.
        Bridging the gulf of evaluation and execution (Norman) Direct
        manipulation (Shneiderman) Eliminate edit-compile cycle
        (Tanimoto) Shortening feedback loop (Hancock)
      </p>
      <p>
      Existing work has focused on enhancing Integrated Development
      Environments (IDEs) with additional graphical user interface
      views and affordances for inspecting and manipulating program
      code and execution. The source code itself is either taken for
      granted (example) or literally part of the IDE (Smalltalk).  In
      this work we make a first step towards turning this hierarchy
      upside-down. Instead of proposing further adornments of the IDE,
      we propose to make the source code itself more dynamic and
      interactive.
      </p>
      <p>
      We introduce <em>live literals</em>: literal data expressions in
      the source code which are updated continuously while the code is
      executed or in reaction to program edit by the programmer. The archetypical example of live literals is captured in the following snippet of code:
      <span class="code">
        doIt("1 + 2", 3);
      </span>
      Whenever the the programmer edits the first
      argument, the second argument is replaced with a literal
      rendering of the result of evaluating the quoted code.  For
      instance, changing <span class="code">"1 + 2"</span>
      to <span class="code">"1 * 2"</span>, changes the
      constant <span class="code">3</span>
      with <span class="code">2</span>.  Live literals thus allow the
      programmer to directly manipulate<label for="sn-direct"
      class="margin-toggle sidenote-number"></label>
      <input type="checkbox" id="sn-direct" class="margin-toggle"/>
      <span class="sidenote">
        	B. Shneiderman, <a href="http://dx.doi.org/10.1109/MC.1983.1654471">Direct Manipulation: A Step Beyond Programming Languages</a>, <em>Computer</em>, Volume 16 , Issue 8, 1983.</span>
      input data from within the code, as well as receive immediate feedback about their actions, also within the code<label for="sn-gulf" class="margin-toggle sidenote-number"></label>
      <input type="checkbox" id="sn-gulf" class="margin-toggle"/>
      <span class="sidenote">
        Henry Lieberman and Christopher Fry, <a href="http://dx.doi.org/10.1145/223904.223969">Bridging the gulf between code and behavior in programming</a>, <em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems (CHI'95)</em>, pp. 480&ndash;486, 1995.
        </span>.
      
      </p>

      <p>
      As a result, the programmer enjoys immediate feedback
      right from the place where it is most relevant, without having
      to switch to different windows or panels. Furthermore, because
      live literals are really just source code, the provided input and computed
      feedback can be copy-pasted, stored, versioned, and shared at
      will.  Finally, since live literals live inside ordinary
      statements and expressions, they play well with ordinary
      programming abstractions, such as loops, conditionals and
      function abstraction.
      </p>
      <p>
      We illustrate live literals using three applications implemented
      in Javascript. The first allows function be annotated with
      example data to explore and test the result of evaluating a
      function.  The second exploits Javascript's object literal
      syntax to represent spreadsheets in ordinary Javascript code.
      Finally, we show how live literals can be used to
      implement <em>probes</em><label for="sn-probe"
      class="margin-toggle sidenote-number"></label>
      <input type="checkbox" id="sn-probe" class="margin-toggle"/>
        <span class="sidenote">
          Sean
          McDirmid, <a href="http://dx.doi.org/10.1145/2509578.2509585">Usable
          Live Programming</a>, <em>Proceedings of the 2013 ACM international symposium on New ideas, new paradigms, and reflections on programming & software (Onward!'13)</em>, pp. 53&ndash;62, 2013.
        </span>
, which are basically print-statements on steroids.  The paper is
      concluded by briefly reflecting on implementation concerns and
      sketching an outlook for further work.
      </p>
      
      <h3>Live Literals: Syntactic Real-Estate for Direct Manipulation and Immediate Feedback</h3>

      <p>
The more general concept of live text has been coined by Hancock
in his PhD thesis<label for="sn-hancock" class="margin-toggle
sidenote-number"></label> <input type="checkbox" id="sn-hancock"
class="margin-toggle"/>
        <span class="sidenote">Christopher Hancock, <em>Real-time
        programming and the big ideas of computational literacy</em>,
        MIT, 2003</span>.  Live literals can be seen as first level of
        live text where the interaction between programmer and
        programming environment is focused on data, as represented by
        programming language literals.
      </p>      
      <p>
        Ironically, literal expressions represent a mostly overlooked part of  programming languages, and almost taken for granted. 
        All programming languages have them, from the atomic integer, string and boolean literals, to composite literals for representing lists (Lisp), arrays (Ruby, Python, etc.), objects (Javascript, Newtonscript), or XML documents (Scala).
        Normally, literals represent <em>static</em> data, for instance to initialize parts of a computation. They are static, because they are part of the source code which is not assumed to change at run time.
        </p>

      <p>
        Live literals are different. Instead of representing static inputs to some computation, live literals are input and output ports for dynamic data, <em>at edit time</em>.
        Editing a literal may trigger a computation, the result of which will be instantaneously fed back into the source code, at a different location. 
        One literal's input feeds back into another literal's output. 
        As a result, instead of a serial script for the
        computer to execute, the text itself becomes as interactive as
        a user interface.
        </p>

      <p>But why would this be relevant or even useful?
        A first motivation for live literals is simply &#8220;less is more&#8221;.
        Live literals are  part of the primary artifact of the working programmer, the source code. There is no need for separate panels, views or popups, which divert the programmer's attention from the actual source code.
        Consequently, live literals promises a significantly simpler model of the IDE as a whole, since part of the traditional IDE services are taken over by the source code itself.
        Finally, the representation through data literals entails that the language of feedback is the same as the language of code, which again simplifies things considerably.
                In a sense, live literals provide an integration similar to the integration of command language and programming language<label for="sn-mono" class="margin-toggle
        sidenote-number"></label> <input type="checkbox" id="sn-mono"
        class="margin-toggle"/>
        <span class="sidenote">
          Jan Heering and Paul Klint, <a href="http://dx.doi.org/10.1145/3318.3321">Towards Monolingual Programming Environments</a>, <em>ACM Transactions on Programming Languages and Systems</em>, Volume 7 Issue 2, April 1985.
        </span>: one language is simpler to deal with than multiple languages.
        We conjecture that live literals improve feedback, paying the minimum cost in terms of cognitive distance and representation impedance mismatch, virtually eliminating all context switching.
      </p>

      <p>Another benefit of live literals is that reifying input and output data as part of the source code allows this information to be shared. For instance, just like ordinary code, code with live literals can be copy-pasted, persisted on disk, and versioned using a configuration management tool.
        This will be helpful in (online) collaboration settings, where collaborators do not have to follow elaborate instruction to reproduce certain situations within their own workspace.
      </p>

      <p>
        As a final potential benefit of live literals as opposed to separate IDE views is that they are amenable to standard programming abstractions. Since live literals are part of ordinary expressions and statements, they can partake in conditional, looping control-flow, or even functional abstraction. This enables patterns of use hitherto unforeseen, since the user interface of IDEs typically provides only predefined visualizations. This flexibility can be seen as analogous to the Smalltalk <span class="code">self halt.</span> statement to trigger a breakpoint<label for="sn-halt" class="margin-toggle
        sidenote-number"></label> <input type="checkbox" id="sn-halt"
        class="margin-toggle"/>
        <span class="sidenote">
          <a href="http://wiki.squeak.org/squeak/2131">Debugger</a>, Squeak Wiki</span>
        . Since this is an ordinary statement, a conditional breakpoint is simply the same statement wrapped in a conditional: <span class="code">cond ifTrue:[self halt.]</span>. No special support is required in the IDE. Although we have not explored this new power fully, we expect this provides an additional level of flexibility for improving how we interact with our source code.
        </p>
      
    </section>

    <section id="liveliterals">
      <h2>Exploring Live literals</h2>

            <p>
        Below: special case certain Javascript idioms, to be interpreted by the IDE as live literals. Note that the source code is just the source code and runs perfectly fine without the liveness. The special cased methods simply evaluate as ordinary code, possibly have no effect at all, if the primary purpose was increased liveness. 
        </p>

      <h3>Examples and Tests</h3>

      <p>
        A benefit of live programming system is that it is easy to detect mistakes, as the data as well as the code are in one view. With Live Literals, we can also implement light weight unit tests, by adding a 'should' field to classes. A result is then added indicating whether or not the method fulfills the specification.
</p>
  <div id="editor_tests" style="margin-top: 0px; width: 500px; height: 206px; margin-left: 0px;">
function fib(n) {
    test([
      {n: 0, should: 1, result: true},
      {n: 1, should: 3, result: true}
    ]);
    if (n == 0) return 1;
    if (n == 1) return 3;
    var gp = 1, p = 3, me;
    for (var i = 2; i < n + 1; i++) {
        me = 3 * p - gp;
        gp = p;
        p = me;
    }
    return me;
}
  </div>

      <p>
        <span class="marginnote">
          TODO: need more fun example than add.
        </span>
        </p>

      <h3>Embedding Spreadsheets</h3>

      <p>
        Spreadsheets are often used to do simple calculations in which data is summed or multiplied, both within rows are within columns. The benefits of using spreadsheets is that they are easy to use, and live. With Live Literals we can implement such spreadsheet problems.
        </p>

      <p>
In the example below, we want to calculate the average of students in our class, as well as the average of all students.
      </p>
      
      <div id="editor_sheets" style="margin-top: 0px; width: 500px; height: 266px; margin-left: 0px;">cell(function avg(sheet, lab, exam) {
  return (lab + exam) / 2;
});

cell(function classAvg(sheet) {
  return avg('avg', sheet);
});


var grades = sheet([
 {student: 'Felienne', lab: 32343, exam: 9, avg: 16176},
 {student: 'Tijs', lab: 10, exam:7.7, avg: 8.85},
 {student: 'Piet', lab: 4, exam:7.7, avg: 5.85},
 {classAvg: 5396.900000000001}
]);        
  </div>

<p>Explain the example in more detail. Conlude: we get the same behavior as with traditional spreadsheet systems, only the user interface is completely textual.</p>
      
      <h3>Probes</h3>

<p>
</p>

        <figure>
        <label for="mn-bret" class="margin-toggle">&#8853;</label><input type="checkbox" id="mn-bret" class="margin-toggle"/><span class="marginnote">From Bret Victor, <a href="https://vimeo.com/36579366">Inventing on Principle</a>, 23th minute, CUSEC, 2012</span>
        <img src="bret.png" style="width: 700px;"/>
      </figure>

<p>
        Bret has two windows, source code left, execution data on the right.<label for="sn-bret" class="margin-toggle
        sidenote-number"></label> <input type="checkbox"
        id="sn-bret" class="margin-toggle"/>
        <span class="sidenote">
          Bret Victor, <a href="https://vimeo.com/36579366">Inventing on Principle</a>, CUSEC, 2012.
        </span>
        Here we have just one view, the source code which acts as both.
        Probes are just represented using a method call "p". 
</p>
<div id="editor_probes" style="margin-top: 0px; width: 500px; height: 470px; margin-left: 0px;">function binarySearch(key, array) {
    run({key: 'g', array: ['a', 'b', 'c', 'd', 'e', 'f']});

    var low = 0; 
    var high = array.length - 1; 
    
    while (low <= high) {
        p(low, [0,3,5]);
        p(high, [5,5,5]);
        
        var mid = Math.floor((low + high)/2);
        var value = array[mid];

        p(mid, [2,4,5]);
        p(value, ["c","e","f"]);

        if (value < key) {
            low = mid + 1; 
        }
        else if (value > key) {
            high = mid - 1;
        }
        else {
            return mid;
        }
   }
   return -1;
}
      </div>


    </section>
    
    <section>
      <h2>Implementing Live Literals</h2>

      <p>
        Parsing with accurate source locations.
        Origin tracking for probes.
        Pretty printing of added code.
      </p>

      <section>
        <h2>Outlook: Towards Live Text</h2>

        <p>
          limitations: only feedback, which can be represented as literal. 
          Live literals are only the first step towards interactive source code, or live text. 
          <ul>
            <li>REPL
            <li>Refactoring
            <li>Debugger (cf. Smalltalk debugger statement)
          </ul>
          </p>
        
       
	
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.3/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
  var editorTests = ace.edit("editor_tests");
  editorTests.renderer.setShowGutter(false);
    editorTests.setTheme("ace/theme/eclipse");
    editorTests.session.setMode("ace/mode/javascript");
    editorTests.session.setOption("useWorker", false);
    editorTests.getSession().on('change', changeHandler(editorTests));

    var editorSheets = ace.edit("editor_sheets");
    editorSheets.renderer.setShowGutter(false);
    editorSheets.setTheme("ace/theme/eclipse");
    editorSheets.session.setMode("ace/mode/javascript");
    editorSheets.session.setOption("useWorker", false);
    editorSheets.getSession().on('change', changeHandler(editorSheets));


    var editorProbes = ace.edit("editor_probes");
    editorProbes.renderer.setShowGutter(false);
    editorProbes.setTheme("ace/theme/eclipse");
    editorProbes.session.setMode("ace/mode/javascript");
    editorProbes.session.setOption("useWorker", false);
    editorProbes.getSession().on('change', changeHandler(editorProbes));
</script>


</body>
