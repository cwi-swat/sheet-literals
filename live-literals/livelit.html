<!DOCTYPE HTML>
<head>
    <meta charset="utf-8" />
  <link rel="stylesheet" href="tufte.css"/>
  <link rel="stylesheet" href="latex.css"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">
    
<script src="https://cdn.rawgit.com/jquery/esprima/2.7.2/esprima.js"></script>
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="libsheet.js"></script>

  <script>
    $(document).ready(function() {
//    app.run();
    });
  </script>

    <style type="text/css" media="screen">
    #editor {
        margin: 0;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
    }
    </style>

</head>


<body>
  <article>
    <h1>Live Literals</h1>
    <p class="subtitle">Tijs van der Storm, Felienne Hermans</p>

    <p>
    <blockquote>
      Live programming environments improve programmer experience by
      providing views of program execution which are continuously, and
      instantaneously updated.  In most existing work on liveness,
      these views are considered part of the IDE: separate windows,
      panels, or widgets allow programmers to inspect and interact
      with live data and program execution.  In this paper we present
      &#8220;live literals&#8221; where the source code itself is used
      as vehicle for immediate feedback and direct manipulation.  Live
      literals are like ordinary programming language literals, but
      they are automatically updated after certain changes to the
      code. We illustrate the concept of live literals in Javascript
      using three applications: embedded spreadsheets, live units
      tests, and probes.
    </blockquote>
    </p>

    <section id="intro">
      <h2>Introduction</h2>

      <p>
        Live programming is about improving programmer experience.
        Bridging the gulf of evaluation and execution (Norman) Direct
        manipulation (Shneiderman) Eliminate edit-compile cycle
        (Tanimoto) Shortening feedback loop (Hancock)
      </p>
      <p>
      Existing work has focused on enhancing Integrated Development
      Environments (IDEs) with additional graphical user interface
      views and affordances for inspecting and manipulating program
      code and execution. The source code itself is either taken for
      granted (example) or literally part of the IDE (Smalltalk).  In
      this work we make a first step towards turning this hierarchy
      upside-down. Instead of proposing further adornments of the IDE,
      we propose to make the source code itself more dynamic and
      interactive.
      </p>
      <p>
      We introduce <em>live literals</em>: literal data expressions in
      the source code which are updated continuously while the code is
      executed or in reaction to program edit by the programmer. The archetypical example of live literals is captured in the following snippet of code:
      <span class="code">
        doIt("1 + 2", 3);
      </span>
      Whenever the the programmer edits the first
      argument, the second argument is replaced with a literal
      rendering of the result of evaluating the quoted code.  For
      instance, changing <span class="code">"1 + 2"</span>
      to <span class="code">"1 * 2"</span>, changes the
      constant <span class="code">3</span>
      with <span class="code">2</span>.  Live literals thus allow the
      programmer to directly manipulate<label for="sn-direct"
      class="margin-toggle sidenote-number"></label>
      <input type="checkbox" id="sn-direct" class="margin-toggle"/>
      <span class="sidenote">
        	B. Shneiderman, <a href="http://dx.doi.org/10.1109/MC.1983.1654471">Direct Manipulation: A Step Beyond Programming Languages</a>, <em>Computer</em>, Volume 16 , Issue 8, 1983.</span>
      input data from within the code, as well as receive immediate feedback about their actions, also within the code<label for="sn-gulf" class="margin-toggle sidenote-number"></label>
      <input type="checkbox" id="sn-gulf" class="margin-toggle"/>
      <span class="sidenote">
        Henry Lieberman and Christopher Fry, <a href="http://dx.doi.org/10.1145/223904.223969">Bridging the gulf between code and behavior in programming</a>, <em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems (CHI'95)</em>, pp. 480&ndash;486, 1995.
        </span>.
      
      </p>

      <p>
      As a result, the programmer enjoys immediate feedback
      right from the place where it is most relevant, without having
      to switch to different windows or panels. Furthermore, because
      live literals are really just source code, the provided input and computed
      feedback can be copy-pasted, stored, versioned, and shared at
      will.  Finally, since live literals live inside ordinary
      statements and expressions, they play well with ordinary
      programming abstractions, such as loops, conditionals and
      function abstraction.
      </p>
      <p>
      We illustrate live literals using three applications implemented
      in Javascript. The first allows function be annotated with
      example data to explore and test the result of evaluating a
      function.  The second exploits Javascript's object literal
      syntax to represent spreadsheets in ordinary Javascript code.
      Finally, we show how live literals can be used to
      implement <em>probes</em><label for="sn-probe"
      class="margin-toggle sidenote-number"></label>
      <input type="checkbox" id="sn-probe" class="margin-toggle"/>
        <span class="sidenote">
          Sean
          McDirmid, <a href="http://dx.doi.org/10.1145/2509578.2509585">Usable
          Live Programming</a>, <em>Proceedings of the 2013 ACM international symposium on New ideas, new paradigms, and reflections on programming & software (Onward!'13)</em>, pp. 53&ndash;62, 2013.
        </span>
, which are basically print-statements on steroids.  The paper is
      concluded by briefly reflecting on implementation concerns and
      sketching an outlook for further work.
      </p>
      
      <h3>Live Literals: Syntactic Real-Estate for Direct Manipulation and Immediate Feedback</h3>
      <p>
        Ironically, literal expressions represent a mostly overlooked part of  programming languages, and almost taken for granted. 
        All programming languages have them, from the atomic integer, string and boolean literals, to composite literals for representing lists (Lisp), arrays (Ruby, Python, etc.), objects (Javascript, Newtonscript), or XML documents (Scala).
        Normally, literals represent <em>static</em> data, for instance to initialize parts of a computation. They are static, because they are part of the source code which is not assumed to change at run time.
        </p>

      <p>
        Live literals are different. Instead of representing static inputs to some computation, live literals are input and output ports for dynamic data, <em>at edit time</em>.
        Editing a literal may trigger a computation, the result of which will be instantaneously fed back into the source code, at a different location. 
        One literal's input feeds back into another literal's output. 
        As a result, instead of a serial script for the
        computer to execute, the text itself becomes as interactive as
        a user interface.
        </p>

      <p>But why would this be relevant or even useful?
        A first motivation for live literals is simply &#8220;less is more&#8221;.
        Live literals are  part of the primary artifact of the working programmer, the source code. There is no need for separate panels, views or popups, which divert the programmer's attention from the actual source code.
        Consequently, live literals promises a significantly simpler model of the IDE as a whole, since part of the traditional IDE services are taken over by the source code itself.
        Finally, the representation through data literals entails that the language of feedback is the same as the language of code, which again simplifies things considerably: one language is simpler to deal with than multiple languages.
        We conjecture that live literals improve feedback, paying the minimum cost in terms of cognitive distance and representation impedance mismatch, virtually eliminating all context switching.
      </p>

      <p>Another benefit of live literals is that reifying input and output data as part of the source code allows this information to be shared. For instance, just like ordinary code, code with live literals can be copy-pasted, persisted on disk, and versioned using a configuration management tool.
        This will be helpful in (online) collaboration settings, where collaborators do not have to follow elaborate instruction to reproduce certain situations within their own workspace.
      </p>

      <p>
        As a final potential benefit of live literals as opposed to separate IDE views is that they are amenable to standard programming abstractions. Since live literals are part of ordinary expressions and statements, they can partake in conditional, looping control-flow, or even functional abstraction. This enables patterns of use hitherto unforeseen, since the user interface of IDEs typically provides only predefined visualizations. This flexibility can be seen as analogous to the Smalltalk <span class="code">self halt.</span> statement to trigger a breakpoint<label for="sn-halt" class="margin-toggle
        sidenote-number"></label> <input type="checkbox" id="sn-halt"
        class="margin-toggle"/><span class="sidenote">
          <a href="http://wiki.squeak.org/squeak/2131">Debugger</a>, Squeak Wiki</span>. Since this is an ordinary statement, a conditional breakpoint is simply the same statement wrapped in a conditional: <span class="code">cond ifTrue:[self halt.]</span>. No special support is required in the IDE. Although we have not fully explored this new power, we expect this to provide an additional level of flexibility for improving how we interact with our source code.
        </p>
      
    </section>

    <section id="liveliterals">
      <h2>Exploring Live Literals: What You Program is What You See (WYPIWYS)</h2>

            <p>
              Below we discuss three applications of live literals in Javascript: live tests, embedded spreadsheets and probes. The editors give special meaning to certain Javascript function calls containing data literals, and then change the source text of those literals depending on the application. Note that the code is ordinary Javascript: without the live literal IDE support, the code just runs as is, and the special cased function calls simply compute results valid or gracefully degrade into no-ops. The examples are all live, so the reader is encouraged to tinker with the source code and observe what happens.
              
        </p>

      <h3>Examples and Tests</h3>

      <p>
        The first application of live literals allows the programmer to explore the behavior of a function definition using live data and live tests, similar to Gilad Bracha's live methods<label for="sn-gilad" class="margin-toggle
        sidenote-number"></label> <input type="checkbox" id="sn-gilad"
        class="margin-toggle"/><span class="sidenote">Gilad Bracha, 
          <a href="http://gbracha.blogspot.nl/2013/04/making-methods-live.html">Making Methods Live</a>, Room 101, April, 2013.</span>. The code below shows a function to compute the factors of integers.         
      </p>
        <figure>
          <label for="mn-tests" class="margin-toggle">&#8853;</label><input type="checkbox" id="mn-tests" class="margin-toggle"/><span class="marginnote"><em>Live examples and tests</em>. Change the value of the <em>n</em> input parameter in the test literal and observe that the <em>result</em> output entry is updated. A <em>should</em> entry changes the literal to a test literal, and <em>result</em> indicates success or failure.</span>
          <div id="editor_tests" style="background-color: #fffff8; margin-top: 0px; width: 500px; height: 266px; margin-left: 0px;">function factors(n) {
  test([
    {n: 0, result: []},
    {n: 4, should: [1,4,2], result: true}
  ]);
  var fs = [];
  for (var i = 1; i <= Math.floor(Math.sqrt(n)); i++)
    if (n % i === 0) {
      fs.push(i);
      if (n / i !== i) fs.push(n / i);
    }
  return fs;
}</div>
      </figure>
      <p>
        The <span class="code">test</span> invocation at the beginning describes a fixture for executing <span class="code">factors</span>.
        The fixture is a plain Javascript array containing object literals specifying input and output of executing <span class="code">factors</span>.
        For instance, the first object literal represents the base case where <span class="code">n</span> is zero. The result field shows that zero does not have any factors. Try changing the constant 0 to another number and observe that the result component changes. 
        The second literal represents a test. In this case, the user provides a <span class="code">should</span> entry, containing the expected result. If this component is present, the test interpreter checks the result of evaluating the function against the expected result, and indicates success or failure of the test in the <span class="code">result</span> entry.
        Again, this result is updated whenever the input or expected output literals are modified. 
      </p>


      <h3>Embedding Spreadsheets</h3>

      <p>
        Spreadsheets are well-known end-user programming environments for managing tabular data and simple computations.
        One advantage of spreadsheets is their liveness: the grid-based user interface supports directly manipulation of input data, code expressions and the effect of changes  immediately reflected in the grid itself.
        Live literals support the same style of live programming, but this time directly within the source code instead of a grid-based UI. 
        </p>

      <p>
        The code below shows a simple spreadsheet for calculating grade averages and the class average based on lab and exam grades for students. 
        </p>

<figure>      
        <label for="mn-sheet" class="margin-toggle">&#8853;</label><input type="checkbox" id="mn-sheet" class="margin-toggle"/><span class="marginnote"><em>Embedded spreadsheets in code</em>. The grades sheet shows both input data (<span class="code">lab</span> and <span class="code">exam</span>) and computed values (<span class="code">classAvg</span> and <span class="code">avg</span>). Changing the input cells or the cell functions triggers updating the sheet.</span>
      <div id="editor_sheets" style="background-color: #fffff8; margin-top: 0px; width: 500px; height: 266px; margin-left: 0px;">cell(function avg(sheet, lab, exam) {
  return (lab + exam) / 2;
});

cell(function classAvg(sheet) {
  return avg('avg', sheet);
});

var grades = sheet([
 {classAvg: 8.375},
 {student: 'James', lab: 9, exam: 9, avg: 9},
 {student: 'Sean', lab: 8.5, exam: 7, avg: 7.75}
]);</div>
</figure>

      <p>
        The first two statements define two cell functions using the <span class="code">cell</span> function which is provided by our framework. The first one defines the average of the lab and exam grades. The second one computes the class average over the complete sheet. The library function <span class="code">avg</span> computes the average over a named column (in this case 'avg'). Both cell function get the complete sheet as the first argument.
      </p>

      <p>The cell functions are automatically applied to the sheet literal created using the <span class="code">sheet</span> function. For every row the available data cells (lab and exam) are matched to the formal parameters of the cell functions, and if there is a match, the computed cell (named after the cell function) is inserted or updated in that row. For instance, the last two rows of the sheet literal contain the avg cell, since both these rows contain lab and exam, as required by the cell function avg. The first row, however, does have these input cells, so does not get the avg cell.
        In the background, the <span class="code">sheet</span> function computes all dependencies between cells and evaluates the computed cells. The result is then piped back into the editor to reflect the actual state of the sheet. 
        The result is that sheet literals provide the same live behavior as  traditional spreadsheet systems, only the user interface is completely textual.</p>
      
      <h3>Probes</h3>

<p>
</p>

        <figure>
        <label for="mn-bret" class="margin-toggle">&#8853;</label><input type="checkbox" id="mn-bret" class="margin-toggle"/><span class="marginnote">From Bret Victor, <a href="https://vimeo.com/36579366">Inventing on Principle</a>, 23th minute, CUSEC, 2012</span>
        <img src="bret.png" style="width: 700px;"/>
      </figure>

<p>
        Bret has two windows, source code left, execution data on the right.
        Here we have just one view, the source code which acts as both.
        Probes are just represented using a method call "p". 
</p>
<figure>
  <label for="mn-probe" class="margin-toggle">&#8853;</label><input type="checkbox" id="mn-probe" class="margin-toggle"/><span class="marginnote"><em>Probes</em>. The <span class="code">run</span> command at the start of a method executes the current method with the provide input parameters. The function <span class="code">p</span> shows the runtime value of the first argument in the array of the second argument. Within loops, <span class="code">p</span> shows the succesive values of the expression.</span>
<div id="editor_probes" style="background-color: #fffff8; margin-top: 0px; width: 550px; height: 500px; margin-left: 0px;">function binarySearch(key, array) {
    run({key: 'g', array: ['a', 'b', 'c', 'd', 'e', 'f']});

    var low = 0; 
    var high = array.length - 1; 
    
    while (low <= high) {
        p(low, [0,3,5]);
        p(high, [5,5,5]);
        
        var mid = Math.floor((low + high)/2);
        var value = array[mid];

        p(mid, [2,4,5]);
        p(value, ["c","e","f"]);

        if (value < key)
            low = mid + 1; 
        else if (value > key)
            high = mid - 1;
        else
            return mid;
   }
   return -1;
}</div>
</figure>

    </section>
    
    <section>
      <h2>Discussion and Outlook</h2>

      <h3>Implementing Live Literals</h3>

      <p>
        Parsing with accurate source locations.
        Origin tracking for probes.
        Pretty printing of added code.
      </p>


      <h3>Related Work</h3>
      <p>
        Smalltalk: but we propose bring IDE closer to source code, whereas in smalltalk de direction is the other way round: there is only IDE, and source code proper is limited to actual method bodies.
        In a sense, live literals provide an integration similar to the integration of command language and programming language<label for="sn-mono" class="margin-toggle
        sidenote-number"></label> <input type="checkbox" id="sn-mono"
        class="margin-toggle"/>
        <span class="sidenote">
          Jan Heering and Paul Klint, <a href="http://dx.doi.org/10.1145/3318.3321">Towards Monolingual Programming Environments</a>, <em>ACM Transactions on Programming Languages and Systems</em>, Volume 7, Issue 2, pp. 183&ndash;213, 1985.
        </span>.
        of which the Smalltalk and Lisp provide the typical examples. However, actually changing the source code itself to provide feedback is not part of this story. 
        </p>

      <p>
The more general concept of live text has been coined by Hancock
in his PhD thesis<label for="sn-hancock" class="margin-toggle
sidenote-number"></label> <input type="checkbox" id="sn-hancock"
class="margin-toggle"/>
        <span class="sidenote">Christopher Hancock, <em>Real-time
        programming and the big ideas of computational literacy</em>,
        MIT, 2003</span>.  Live literals can be seen as first level of
        live text where the interaction between programmer and
        programming environment is focused on data, as represented by
        programming language literals.
      </p>      


      <p>
        Full obliteration of the distiction between source code an GUI is represented by programming systems based on structure editing (or projectional), like MPS<label for="sn-mps" class="margin-toggle
sidenote-number"></label> <input type="checkbox" id="sn-mps"
class="margin-toggle"/>
        <span class="sidenote">Jetbrains, <a href="https://www.jetbrains.com/mps/">Meta Programming System (MPS)</a></span>. Such systems represent the opposite end of the spectrum regarding integration: there is no source code at all, the only interface is the graphical user interface.
        Although this provides arbitrary freedom to mix-and-match different notations, views and languages, the benefits of sharing and maintaining code using standard, textual tools are lost. 
        </p>
      
        <h3>Outlook: Towards Live Text</h3>

        <p>
          limitations: only feedback, which can be represented as literal. 
          Live literals are only the first step towards interactive source code, or live text. 
          <ul>
            <li>REPL
            <li>Changing code with code Refactoring
            <li>New syntax (e.g. textual stack frame?)
          </ul>
          </p>
        
       
	
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.3/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
  var editorTests = ace.edit("editor_tests");
  editorTests.renderer.setShowGutter(false);
    editorTests.setTheme("ace/theme/eclipse");
    editorTests.session.setMode("ace/mode/javascript");
    editorTests.session.setOption("useWorker", false);
    editorTests.getSession().on('change', changeHandler(editorTests));
  editorTests.setOptions({
  fontSize: "11pt"
  });
  
    var editorSheets = ace.edit("editor_sheets");
    editorSheets.renderer.setShowGutter(false);
    editorSheets.setTheme("ace/theme/eclipse");
    editorSheets.session.setMode("ace/mode/javascript");
    editorSheets.session.setOption("useWorker", false);
    editorSheets.getSession().on('change', changeHandler(editorSheets));
  editorSheets.setOptions({
  fontSize: "11pt"
  });


    var editorProbes = ace.edit("editor_probes");
    editorProbes.renderer.setShowGutter(false);
    editorProbes.setTheme("ace/theme/eclipse");
    editorProbes.session.setMode("ace/mode/javascript");
    editorProbes.session.setOption("useWorker", false);
  editorProbes.getSession().on('change', changeHandler(editorProbes));
  editorProbes.setOptions({
  fontSize: "11pt"
  });
  
</script>


</body>
