<!DOCTYPE HTML>
<head>
    <meta charset="utf-8" />
  <link rel="stylesheet" href="tufte.css"/>
  <link rel="stylesheet" href="latex.css"/>
  <meta name="viewport" content="width=device-width, initial-scale=1">
    
<script src="https://cdn.rawgit.com/jquery/esprima/2.7.2/esprima.js"></script>
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="libsheet.js"></script>

  <script>
    $(document).ready(function() {
//    app.run();
    });
  </script>

    <style type="text/css" media="screen">
    #editor {
        margin: 0;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
    }
    </style>

</head>


<body>
  <article>
    <h1>Live Literals</h1>
    <p class="subtitle">Felienne Hermans, Tijs van der Storm</p>

    <blockquote>
      Live programming environments improve programmer experience by
      providing views of program execution which are continuously, and
      instantaneously updated.  In most existing work on liveness,
      these views are considered part of the IDE: separate windows,
      panels, or widgets allow programmers to inspect and interact
      with live data and program execution.  In this paper we present
      &#8220;live literals&#8221; where the source code itself is used
      as vehicle for immediate feedback and direct manipulation.  Live
      literals are like ordinary programming language literals, but
      they are automatically updated after certain changes to the
      code. We illustrate the concept of live literals in Javascript
      using three applications: embedded spreadsheets, live units
      tests, and probes.
    </blockquote>

    <section id="intro">
      <h2>Introduction</h2>

      <p>
        Live programming is about improving programmer experience.
        Bridging the gulf of evaluation and execution (Norman) Direct
        manipulation (Shneiderman) Eliminate edit-compile cycle
        (Tanimoto) Shortening feedback loop (Hancock)
      </p>
      <p>
      Existing work has focused on enhancing Integrated Development
      Environments (IDEs) with additional graphical user interface
      views and affordances for inspecting and manipulating program
      code and execution. The source code itself is either taken for
      granted (example) or literally part of the IDE (Smalltalk).  In
      this work we make a first step towards turning this hierarchy
      upside-down. Instead of proposing further adornments of the IDE,
      we propose to make the source code itself more dynamic and
      interactive.
      </p>
      <p>
      We introduce <em>live literals</em>: literal data expressions in
      the source code which are updated continuously while the code is
      executed or in reaction to program edit by the programmer. The archetypical example of live literals is captured in the following snippet of code:
      <span class="code">
        doIt("1 + 2", 3);
      </span>
      Whenever the the programmer edits the first
      argument, the second argument is replaced with a literal
      rendering of the result of evaluating the quoted code.  For
      instance, changing <span class="code">"1 + 2"</span>
      to <span class="code">"1 * 2"</span>, changes the
      constant <span class="code">3</span>
      with <span class="code">2</span>.  Live literals thus allow the
      programmer to directly manipulate<label for="sn-direct"
      class="margin-toggle sidenote-number"></label>
      <input type="checkbox" id="sn-direct" class="margin-toggle"/>
      <span class="sidenote">
        	B. Shneiderman, <a href="http://dx.doi.org/10.1109/MC.1983.1654471">Direct Manipulation: A Step Beyond Programming Languages</a>, <em>Computer</em>, Volume 16 , Issue 8, 1983.</span>
      input data from within the code, as well as receive immediate feedback about their actions, also within the code<label for="sn-gulf" class="margin-toggle sidenote-number"></label>
      <input type="checkbox" id="sn-gulf" class="margin-toggle"/>
      <span class="sidenote">
        Henry Lieberman and Christopher Fry, <a href="http://dx.doi.org/10.1145/223904.223969">Bridging the gulf between code and behavior in programming</a>, <em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems (CHI'95)</em>, pp. 480&ndash;486, 1995.
        </span>.
      
      </p>

      <p>
      As a result, the programmer enjoys immediate feedback
      right from the place where it is most relevant, without having
      to switch to different windows or panels. Furthermore, because
      live literals are really just source code, the provided input and computed
      feedback can be copy-pasted, stored, versioned, and shared at
      will.  Finally, since live literals live inside ordinary
      statements and expressions, they play well with ordinary
      programming abstractions, such as loops, conditionals and
      function abstraction.
      </p>
      <p>
      We illustrate live literals using three applications implemented
      in Javascript. The first allows function be annotated with
      example data to explore and test the result of evaluating a
      function.  The second exploits Javascript's object literal
      syntax to represent spreadsheets in ordinary Javascript code.
      Finally, we show how live literals can be used to
      implement <em>probes</em><label for="sn-probe"
      class="margin-toggle sidenote-number"></label>
      <input type="checkbox" id="sn-probe" class="margin-toggle"/>
        <span class="sidenote">
          Sean
          McDirmid, <a href="http://research.microsoft.com/apps/pubs/default.aspx?id=189802">Usable
          Live Programming</a>, <em>SPLASH Onward!</em>, 2013.
        </span>
, which are basically print-statements on steroids.  The paper is
      concluded by briefly reflecting on implementation concerns and
      sketching an outlook for further work.
      </p>
      
      <h3>Live Literals: Syntactic Real-Estate for Direct Manipulation and Immediate Feedback</h3>

      <p>
The more general concept of live text has been introduced by Hancock
in his PhD thesis<label for="sn-hancock" class="margin-toggle
sidenote-number"></label> <input type="checkbox" id="sn-hancock"
class="margin-toggle"/>
        <span class="sidenote">Christopher Hancock, <em>Real-time
        programming and the big ideas of computational literacy</em>,
        MIT, 2003</span>.  Live literals can be seen as first level of
        live text where the interaction between programmer and
        programming environment is focused on data, as represented by
        programming language literals.
      </p>      
      <p>
        Ironically, literal expressions represent  a mostly overlooked part of  programming languages, and almost taken for granted. 
        All programming languages have them, from the atomic integer, string and boolean literals, to composite literals for representing lists (Lisp), arrays (Ruby, Python, etc.), or objects (Javascript, Newtonscript).
        Normally, literals represent <em>static</em> data, for instance to initialize parts of a computation. They are static, because they are part of the source code which is not assumed to change at run time.
        </p>

      <p>
        Live literals are different. Instead of representing static inputs to some computation, live literals are input and output ports for dynamic data.
        Editing a literal may trigger a computation at edit time, the result of which will be fed back into the source code, at a different location. 
        One literal's input feeds back into another literal's output. 
        As a result, instead of a serial script for the
        computer to execute, the text itself becomes as interactive as
        a user interface.
        </p>

      <p>Motvation: sharing, persistence, versioning, copy-paste.  No
        separate views: minimize distance.  Single language, in the
        old days: command language vs programming language.  In 1985,
        Heering and Klint argued for integrating a programming
        environments command languages and programming
        language.<label for="sn-mono" class="margin-toggle
        sidenote-number"></label> <input type="checkbox" id="sn-mono"
        class="margin-toggle"/>
        <span class="sidenote">
          Jan Heering, Paul Klint, <a href="http://dx.doi.org/10.1145/3318.3321">Towards Monolingual Programming Environments</a>, <em>ACM Transactions on Programming Languages and Systems</em>, Volume 7 Issue 2, April 1985.
        </span> However, they did not consider the option of using source code as output medium as well. 

        Composing with existing language constructs and abstractions.
      </p>
      <p>
        Below: special case certain Javascript idioms, to be interpreted by the IDE as live literals. Note that the source code is just the source code and runs perfectly fine without the liveness. The special cased methods simply evaluate as ordinary code, possibly have no effect at all, if the primary purpose was increased liveness. 
        </p>
      
    </section>

    <section id="liveliterals">
      <h2>Exploring Live literals</h2>

      <h3>Examples and Tests</h3>

      <p>
        A benefit of live programming system is that it is easy to detect mistakes, as the data as well as the code are in one view. With Live Literals, we can also implement light weight unit tests, by adding a 'should' field to classes. A result is then added indicating whether or not the method fulfills the specification.
</p>
  <div id="editor_tests" style="margin-top: 0px; width: 500px; height: 206px; margin-left: 0px;">
function fib(n) {
    test([
      {n: 0, should: 1, result: true},
      {n: 1, should: 3, result: true}
    ]);
    if (n == 0) return 1;
    if (n == 1) return 3;
    var gp = 1, p = 3, me;
    for (var i = 2; i < n + 1; i++) {
        me = 3 * p - gp;
        gp = p;
        p = me;
    }
    return me;
}
  </div>

      <p>
        <span class="marginnote">
          TODO: need more fun example than add.
        </span>
        </p>

      <h3>Embedding Spreadsheets</h3>

      <p>
        Spreadsheets are often used to do simple calculations in which data is summed or multiplied, both within rows are within columns. The benefits of using spreadsheets is that they are easy to use, and live. With Live Literals we can implement such spreadsheet problems.
        </p>

      <p>
In the example below, we want to calculate the average of students in our class, as well as the average of all students.
      </p>
      
      <div id="editor_sheets" style="margin-top: 0px; width: 500px; height: 266px; margin-left: 0px;">cell(function avg(sheet, lab, exam) {
  return (lab + exam) / 2;
});

cell(function classAvg(sheet) {
  return avg('avg', sheet);
});


var grades = sheet([
 {student: 'Felienne', lab: 32343, exam: 9, avg: 16176},
 {student: 'Tijs', lab: 10, exam:7.7, avg: 8.85},
 {student: 'Piet', lab: 4, exam:7.7, avg: 5.85},
 {classAvg: 5396.900000000001}
]);        
  </div>

<p>Explain the example in more detail. Conlude: we get the same behavior as with traditional spreadsheet systems, only the user interface is completely textual.</p>
      
      <h3>Probes</h3>

<p>
</p>

        <figure>
        <label for="mn-bret" class="margin-toggle">&#8853;</label><input type="checkbox" id="mn-bret" class="margin-toggle"/><span class="marginnote">From Bret Victor, <a href="https://vimeo.com/36579366">Inventing on Principle</a>, 23th minute, CUSEC, 2012</span>
        <img src="bret.png" style="width: 700px;"/>
      </figure>

<p>
        Bret has two windows, source code left, execution data on the right.<label for="sn-bret" class="margin-toggle
        sidenote-number"></label> <input type="checkbox"
        id="sn-bret" class="margin-toggle"/>
        <span class="sidenote">
          Bret Victor, <a href="https://vimeo.com/36579366">Inventing on Principle</a>, CUSEC, 2012.
        </span>
        Here we have just one view, the source code which acts as both.
        Probes are just represented using a method call "p". 
</p>
<div id="editor_probes" style="margin-top: 0px; width: 500px; height: 470px; margin-left: 0px;">function binarySearch(key, array) {
    run({key: 'g', array: ['a', 'b', 'c', 'd', 'e', 'f']});

    var low = 0; 
    var high = array.length - 1; 
    
    while (low <= high) {
        p(low, [0,3,5]);
        p(high, [5,5,5]);
        
        var mid = Math.floor((low + high)/2);
        var value = array[mid];

        p(mid, [2,4,5]);
        p(value, ["c","e","f"]);

        if (value < key) {
            low = mid + 1; 
        }
        else if (value > key) {
            high = mid - 1;
        }
        else {
            return mid;
        }
   }
   return -1;
}
      </div>


    </section>
    
    <section>
      <h2>Implementing Live Literals</h2>

      <p>
        Parsing with accurate source locations.
        Origin tracking for probes.
        Pretty printing of added code.
      </p>

      <section>
        <h2>Outlook: Towards Live Text</h2>

        <p>
          Live literals are only the first step towards interactive source code, or live text. 
          <ul>
            <li>REPL
            <li>Refactoring
            <li>Debugger (cf. Smalltalk debugger statement)
          </ul>
          </p>
        
       
	
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.3/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
  var editorTests = ace.edit("editor_tests");
  editorTests.renderer.setShowGutter(false);
    editorTests.setTheme("ace/theme/eclipse");
    editorTests.session.setMode("ace/mode/javascript");
    editorTests.session.setOption("useWorker", false);
    editorTests.getSession().on('change', changeHandler(editorTests));

    var editorSheets = ace.edit("editor_sheets");
    editorSheets.renderer.setShowGutter(false);
    editorSheets.setTheme("ace/theme/eclipse");
    editorSheets.session.setMode("ace/mode/javascript");
    editorSheets.session.setOption("useWorker", false);
    editorSheets.getSession().on('change', changeHandler(editorSheets));


    var editorProbes = ace.edit("editor_probes");
    editorProbes.renderer.setShowGutter(false);
    editorProbes.setTheme("ace/theme/eclipse");
    editorProbes.session.setMode("ace/mode/javascript");
    editorProbes.session.setOption("useWorker", false);
    editorProbes.getSession().on('change', changeHandler(editorProbes));
</script>


</body>
